"use strict";
/**
 * tiktok shop openapi
 * sdk for apis
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.ReturnRefundV202309ApiOperationNames = exports.ReturnRefundV202309Api = exports.ReturnRefundV202309ApiApiKeys = void 0;
var request_1 = __importDefault(require("request"));
var models_1 = require("../model/models");
var apis_1 = require("./apis");
var defaultBasePath = 'https://open-api.tiktokglobalshop.com';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var ReturnRefundV202309ApiApiKeys;
(function (ReturnRefundV202309ApiApiKeys) {
})(ReturnRefundV202309ApiApiKeys = exports.ReturnRefundV202309ApiApiKeys || (exports.ReturnRefundV202309ApiApiKeys = {}));
var ReturnRefundV202309Api = /** @class */ (function () {
    function ReturnRefundV202309Api(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new models_1.VoidAuth()
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(ReturnRefundV202309Api.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ReturnRefundV202309Api.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ReturnRefundV202309Api.prototype, "defaultHeaders", {
        get: function () {
            return this._defaultHeaders;
        },
        set: function (defaultHeaders) {
            this._defaultHeaders = defaultHeaders;
        },
        enumerable: false,
        configurable: true
    });
    ReturnRefundV202309Api.prototype.setDefaultAuthentication = function (auth) {
        this.authentications["default"] = auth;
    };
    ReturnRefundV202309Api.prototype.setApiKey = function (key, value) {
        this.authentications[ReturnRefundV202309ApiApiKeys[key]].apiKey = value;
    };
    ReturnRefundV202309Api.prototype.addInterceptor = function (interceptor) {
        this.interceptors.push(interceptor);
    };
    /**
     * Use this API to approve a buyer\'s order cancellation request.
     * @summary ApproveCancellation
     * @param cancelId The identifier of a specific cancellation request.
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param idempotencyKey The idempotency key is a unique value generated by the client which the server uses to recognize a request.   You may choose your own method of creating unique keys. We suggest using UUIDs, or another random string with enough entropy, to avoid collisions.   Idempotency keys can be up to 255 characters long.
     * @param shopCipher
     */
    ReturnRefundV202309Api.prototype.CancellationsCancelIdApprovePost = function (cancelId, xTtsAccessToken, contentType, idempotencyKey, shopCipher, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_1, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/cancellations/{cancel_id}/approve'
                    .replace('{' + 'cancel_id' + '}', encodeURIComponent(String(cancelId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'cancelId' is not null or undefined
                if (cancelId === null || cancelId === undefined) {
                    throw new Error('Required parameter cancelId was null or undefined when calling CancellationsCancelIdApprovePost.');
                }
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling CancellationsCancelIdApprovePost.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling CancellationsCancelIdApprovePost.');
                }
                if (idempotencyKey !== undefined) {
                    localVarQueryParameters['idempotency_key'] = models_1.ObjectSerializer.serialize(idempotencyKey, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_1 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_1(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309ApproveCancellationResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to reject a buyer\'s order cancellation request.
     * @summary RejectCancellation
     * @param cancelId The identifier of a specific cancellation request.
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param idempotencyKey The idempotency key is a unique value generated by the client which the server uses to recognize a request.   You may choose your own method of creating unique keys. We suggest using UUIDs, or another random string with enough entropy, to avoid collisions.   Idempotency keys can be up to 255 characters long.
     * @param shopCipher
     * @param RejectCancellationRequestBody
     */
    ReturnRefundV202309Api.prototype.CancellationsCancelIdRejectPost = function (cancelId, xTtsAccessToken, contentType, idempotencyKey, shopCipher, RejectCancellationRequestBody, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_2, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/cancellations/{cancel_id}/reject'
                    .replace('{' + 'cancel_id' + '}', encodeURIComponent(String(cancelId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'cancelId' is not null or undefined
                if (cancelId === null || cancelId === undefined) {
                    throw new Error('Required parameter cancelId was null or undefined when calling CancellationsCancelIdRejectPost.');
                }
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling CancellationsCancelIdRejectPost.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling CancellationsCancelIdRejectPost.');
                }
                if (idempotencyKey !== undefined) {
                    localVarQueryParameters['idempotency_key'] = models_1.ObjectSerializer.serialize(idempotencyKey, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(RejectCancellationRequestBody, "ReturnRefund202309RejectCancellationRequestBody")
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_2 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_2(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309RejectCancellationResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to cancel an order on behalf of a seller. In the US and UK markets, when an item is out of stock, partial cancellation on the single item level is supported by this API.
     * @summary CancelOrder
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param shopCipher
     * @param CancelOrderRequestBody
     */
    ReturnRefundV202309Api.prototype.CancellationsPost = function (xTtsAccessToken, contentType, shopCipher, CancelOrderRequestBody, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_3, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/cancellations';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling CancellationsPost.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling CancellationsPost.');
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(CancelOrderRequestBody, "ReturnRefund202309CancelOrderRequestBody")
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_3 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_3(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309CancelOrderResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to search and retrieve one or more order cancellations.
     * @summary SearchCancellations
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param sortField The returned results will be sorted by the specified field.  Default: create_time Possible values: - create_time - update_time  Specify the order for sorting the returned results by using the sort_order parameter.
     * @param sortOrder The sort order for the sort_field parameter.  Default: ASC Possible values: - ASC: Ascending order - DESC: Descending order
     * @param pageSize The number of results to be returned per page.  Default: 10.  Valid range: [1-50].
     * @param pageToken An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the next_page_token from a previous response. It is not needed for the first page.
     * @param shopCipher
     * @param SearchCancellationsRequestBody
     */
    ReturnRefundV202309Api.prototype.CancellationsSearchPost = function (xTtsAccessToken, contentType, sortField, sortOrder, pageSize, pageToken, shopCipher, SearchCancellationsRequestBody, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_4, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/cancellations/search';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling CancellationsSearchPost.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling CancellationsSearchPost.');
                }
                if (sortField !== undefined) {
                    localVarQueryParameters['sort_field'] = models_1.ObjectSerializer.serialize(sortField, "string");
                }
                if (sortOrder !== undefined) {
                    localVarQueryParameters['sort_order'] = models_1.ObjectSerializer.serialize(sortOrder, "string");
                }
                if (pageSize !== undefined) {
                    localVarQueryParameters['page_size'] = models_1.ObjectSerializer.serialize(pageSize, "string");
                }
                if (pageToken !== undefined) {
                    localVarQueryParameters['page_token'] = models_1.ObjectSerializer.serialize(pageToken, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(SearchCancellationsRequestBody, "ReturnRefund202309SearchCancellationsRequestBody")
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_4 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_4(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309SearchCancellationsResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to check eligible aftersale solutions for an order, including whether the seller or buyer can initiate a refund, return, or cancel a specific order.
     * @summary GetAftersaleEligibility
     * @param orderId The unique identifier for a TikTok Shop order.
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param initiateAftersaleUser The type of user you would like to check aftersale options for. Default: SELLER Possible values: - SELLER - BUYER
     * @param shopCipher
     */
    ReturnRefundV202309Api.prototype.OrdersOrderIdAftersaleEligibilityGet = function (orderId, xTtsAccessToken, contentType, initiateAftersaleUser, shopCipher, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_5, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/orders/{order_id}/aftersale_eligibility'
                    .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'orderId' is not null or undefined
                if (orderId === null || orderId === undefined) {
                    throw new Error('Required parameter orderId was null or undefined when calling OrdersOrderIdAftersaleEligibilityGet.');
                }
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling OrdersOrderIdAftersaleEligibilityGet.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling OrdersOrderIdAftersaleEligibilityGet.');
                }
                if (initiateAftersaleUser !== undefined) {
                    localVarQueryParameters['initiate_aftersale_user'] = models_1.ObjectSerializer.serialize(initiateAftersaleUser, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_5 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_5(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309GetAftersaleEligibilityResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to check order refundable amounts.
     * @summary CalculateRefund
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param shopCipher
     * @param CalculateRefundRequestBody
     */
    ReturnRefundV202309Api.prototype.RefundsCalculatePost = function (xTtsAccessToken, contentType, shopCipher, CalculateRefundRequestBody, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_6, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/refunds/calculate';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling RefundsCalculatePost.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling RefundsCalculatePost.');
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(CalculateRefundRequestBody, "ReturnRefund202309CalculateRefundRequestBody")
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_6 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_6(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309CalculateRefundResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to obtain order return or cancellation rejection reasons. The seller is required to provide a reason when they reject a cancel, refund, or return request.
     * @summary GetRejectReasons
     * @param returnOrCancelId The unique identifier for an order return or cancellation.
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param locale The BCP-47 locale codes for displaying the rejection reason, delimited by commas. Default: en-US Refer to [Locale codes](678e3a47bae28f030a8c7523) for the list of supported locale codes.
     * @param shopCipher
     */
    ReturnRefundV202309Api.prototype.RejectReasonsGet = function (returnOrCancelId, xTtsAccessToken, contentType, locale, shopCipher, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_7, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/reject_reasons';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'returnOrCancelId' is not null or undefined
                if (returnOrCancelId === null || returnOrCancelId === undefined) {
                    throw new Error('Required parameter returnOrCancelId was null or undefined when calling RejectReasonsGet.');
                }
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling RejectReasonsGet.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling RejectReasonsGet.');
                }
                if (locale !== undefined) {
                    localVarQueryParameters['locale'] = models_1.ObjectSerializer.serialize(locale, "string");
                }
                if (returnOrCancelId !== undefined) {
                    localVarQueryParameters['return_or_cancel_id'] = models_1.ObjectSerializer.serialize(returnOrCancelId, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_7 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_7(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309GetRejectReasonsResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to initiate a return request on behalf of the buyer Sellers can reject the request, or accept and issue: -Return and Refund (buyer must send package back) -Returnless Refund (buyer can keep the item) -Partial Refund (Seller issues a partial refund, buyer can keep the item)
     * @summary CreateReturn
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param idempotencyKey Idempotency Key
     * @param shopCipher
     * @param CreateReturnRequestBody
     */
    ReturnRefundV202309Api.prototype.ReturnsPost = function (xTtsAccessToken, contentType, idempotencyKey, shopCipher, CreateReturnRequestBody, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_8, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/returns';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling ReturnsPost.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling ReturnsPost.');
                }
                if (idempotencyKey !== undefined) {
                    localVarQueryParameters['idempotency_key'] = models_1.ObjectSerializer.serialize(idempotencyKey, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(CreateReturnRequestBody, "ReturnRefund202309CreateReturnRequestBody")
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_8 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_8(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309CreateReturnResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to approve a buyer\'s return request.
     * @summary ApproveReturn
     * @param returnId The identifier of a specific return request.
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param idempotencyKey The idempotency key is a unique value generated by the client which the server uses to recognize the same request. How you create unique keys is up to you, but we suggest using UUIDs, or another random string with enough entropy to avoid collisions. Idempotency keys can be up to 255 characters long.
     * @param shopCipher
     * @param ApproveReturnRequestBody
     */
    ReturnRefundV202309Api.prototype.ReturnsReturnIdApprovePost = function (returnId, xTtsAccessToken, contentType, idempotencyKey, shopCipher, ApproveReturnRequestBody, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_9, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/returns/{return_id}/approve'
                    .replace('{' + 'return_id' + '}', encodeURIComponent(String(returnId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'returnId' is not null or undefined
                if (returnId === null || returnId === undefined) {
                    throw new Error('Required parameter returnId was null or undefined when calling ReturnsReturnIdApprovePost.');
                }
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling ReturnsReturnIdApprovePost.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling ReturnsReturnIdApprovePost.');
                }
                if (idempotencyKey !== undefined) {
                    localVarQueryParameters['idempotency_key'] = models_1.ObjectSerializer.serialize(idempotencyKey, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(ApproveReturnRequestBody, "ReturnRefund202309ApproveReturnRequestBody")
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_9 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_9(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309ApproveReturnResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to get a list of return records.
     * @summary GetReturnRecords
     * @param returnId A unique identifier for a TikTok Shop return request.
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param locale The BCP-47 locale codes for displaying the return reason, delimited by commas. Default: en-US Refer to [Locale codes](678e3a47bae28f030a8c7523) for the list of supported locale codes.
     * @param shopCipher
     */
    ReturnRefundV202309Api.prototype.ReturnsReturnIdRecordsGet = function (returnId, xTtsAccessToken, contentType, locale, shopCipher, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_10, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/returns/{return_id}/records'
                    .replace('{' + 'return_id' + '}', encodeURIComponent(String(returnId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'returnId' is not null or undefined
                if (returnId === null || returnId === undefined) {
                    throw new Error('Required parameter returnId was null or undefined when calling ReturnsReturnIdRecordsGet.');
                }
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling ReturnsReturnIdRecordsGet.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling ReturnsReturnIdRecordsGet.');
                }
                if (locale !== undefined) {
                    localVarQueryParameters['locale'] = models_1.ObjectSerializer.serialize(locale, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_10 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_10(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309GetReturnRecordsResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to reject a buyer\'s return or refund request.
     * @summary RejectReturn
     * @param returnId The identifier of a specific return request.
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param idempotencyKey The idempotency key is a unique value generated by the client which the server uses to recognize the same request. How you create unique keys is up to you, but we suggest using UUIDs, or another random string with enough entropy to avoid collisions. Idempotency keys can be up to 255 characters long.
     * @param shopCipher
     * @param RejectReturnRequestBody
     */
    ReturnRefundV202309Api.prototype.ReturnsReturnIdRejectPost = function (returnId, xTtsAccessToken, contentType, idempotencyKey, shopCipher, RejectReturnRequestBody, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_11, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/returns/{return_id}/reject'
                    .replace('{' + 'return_id' + '}', encodeURIComponent(String(returnId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'returnId' is not null or undefined
                if (returnId === null || returnId === undefined) {
                    throw new Error('Required parameter returnId was null or undefined when calling ReturnsReturnIdRejectPost.');
                }
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling ReturnsReturnIdRejectPost.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling ReturnsReturnIdRejectPost.');
                }
                if (idempotencyKey !== undefined) {
                    localVarQueryParameters['idempotency_key'] = models_1.ObjectSerializer.serialize(idempotencyKey, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(RejectReturnRequestBody, "ReturnRefund202309RejectReturnRequestBody")
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_11 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_11(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309RejectReturnResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    /**
     * Use this API to retrieve one or more returns. This API supports filtering returns using query parameters. You can filter returns by create time, update time, return status, or return types.
     * @summary SearchReturns
     * @param xTtsAccessToken
     * @param contentType Allowed type: application/json
     * @param sortField The returned results will be sorted by the specified field.  Default: &#x60;create_time&#x60; Possible values: - &#x60;create_time&#x60; - &#x60;update_time&#x60;  Specify the order for sorting the returned results by using the &#x60;sort_order&#x60; parameter.
     * @param sortOrder The sort order for the &#x60;sort_field&#x60; parameter. Default: ASC Possible values: - &#x60;ASC&#x60;: Ascending order - &#x60;DESC&#x60;: Descending order
     * @param pageSize The number of results to be returned per page. Default: 10. Valid range: [10-50].
     * @param pageToken An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
     * @param shopCipher
     * @param SearchReturnsRequestBody
     */
    ReturnRefundV202309Api.prototype.ReturnsSearchPost = function (xTtsAccessToken, contentType, sortField, sortOrder, pageSize, pageToken, shopCipher, SearchReturnsRequestBody, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_12, _i, _a, interceptor;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/return_refund/202309/returns/search';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'xTtsAccessToken' is not null or undefined
                if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
                    throw new Error('Required parameter xTtsAccessToken was null or undefined when calling ReturnsSearchPost.');
                }
                // verify required parameter 'contentType' is not null or undefined
                if (contentType === null || contentType === undefined) {
                    throw new Error('Required parameter contentType was null or undefined when calling ReturnsSearchPost.');
                }
                if (sortField !== undefined) {
                    localVarQueryParameters['sort_field'] = models_1.ObjectSerializer.serialize(sortField, "string");
                }
                if (sortOrder !== undefined) {
                    localVarQueryParameters['sort_order'] = models_1.ObjectSerializer.serialize(sortOrder, "string");
                }
                if (pageSize !== undefined) {
                    localVarQueryParameters['page_size'] = models_1.ObjectSerializer.serialize(pageSize, "string");
                }
                if (pageToken !== undefined) {
                    localVarQueryParameters['page_token'] = models_1.ObjectSerializer.serialize(pageToken, "string");
                }
                if (shopCipher !== undefined) {
                    localVarQueryParameters['shop_cipher'] = models_1.ObjectSerializer.serialize(shopCipher, "string");
                }
                localVarHeaderParams['x-tts-access-token'] = models_1.ObjectSerializer.serialize(xTtsAccessToken, "string");
                localVarHeaderParams['Content-Type'] = models_1.ObjectSerializer.serialize(contentType, "string");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(SearchReturnsRequestBody, "ReturnRefund202309SearchReturnsRequestBody")
                };
                authenticationPromise = Promise.resolve();
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications["default"].applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_12 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_12(interceptor);
                }
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(function (resolve, reject) {
                            (0, request_1["default"])(localVarRequestOptions, function (error, response, body) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                        body = models_1.ObjectSerializer.deserialize(body, "ReturnRefund202309SearchReturnsResponse");
                                        resolve({ response: response, body: body });
                                    }
                                    else {
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                    }
                                }
                            });
                        });
                    })];
            });
        });
    };
    ReturnRefundV202309Api.apiName = 'ReturnRefundV202309Api';
    return ReturnRefundV202309Api;
}());
exports.ReturnRefundV202309Api = ReturnRefundV202309Api;
exports.ReturnRefundV202309ApiOperationNames = {
    CancellationsCancelIdApprovePost: 'CancellationsCancelIdApprovePost', CancellationsCancelIdRejectPost: 'CancellationsCancelIdRejectPost', CancellationsPost: 'CancellationsPost', CancellationsSearchPost: 'CancellationsSearchPost', OrdersOrderIdAftersaleEligibilityGet: 'OrdersOrderIdAftersaleEligibilityGet', RefundsCalculatePost: 'RefundsCalculatePost', RejectReasonsGet: 'RejectReasonsGet', ReturnsPost: 'ReturnsPost', ReturnsReturnIdApprovePost: 'ReturnsReturnIdApprovePost', ReturnsReturnIdRecordsGet: 'ReturnsReturnIdRecordsGet', ReturnsReturnIdRejectPost: 'ReturnsReturnIdRejectPost', ReturnsSearchPost: 'ReturnsSearchPost'
};
